package scala.cli.commands.mamba

import caseapp.core.RemainingArgs
import com.github.plokhotnyuk.jsoniter_scala.core._
import com.github.plokhotnyuk.jsoniter_scala.macros._
import coursier.cache.ArchiveCache
import coursier.cache.internal.FileUtil
import coursier.error.FetchError
import coursier.util.{Artifact, Task}

import java.io.InputStream
import java.math.BigInteger
import java.security.MessageDigest

import scala.build.internal
import scala.cli.commands.ScalaCommand
import scala.cli.commands.mamba.SharedMambaOptionsOps._
import scala.cli.commands.util.CommonOps._

object MambaFreeze extends ScalaCommand[MambaFreezeOptions] {
  override def hidden     = true
  override def inSipScala = false
  override def names = List(
    List("mamba", "freeze")
  )
  def run(options: MambaFreezeOptions, args: RemainingArgs): Unit = {
    val prefix = os.Path(options.prefix, os.pwd)

    val logger       = options.logging.logger
    val cache        = options.coursier.coursierCache(logger.coursierLogger(""))
    val archiveCache = ArchiveCache().withCache(cache)
    val launcher =
      internal.Mamba.launcher(
        options.mamba.microMambaVersion,
        options.mamba.microMambaSuffix,
        options.mamba.condaPlatform,
        archiveCache,
        options.logging.logger
      ).orExit(logger)

    val res    = os.proc(launcher, "list", "-p", prefix, "--json").call()
    val output = res.out.bytes

    logger.debug("micromamba list output: " + System.lineSeparator() + res.out.text())

    // FIXME Print nice error if parsing fails
    val elems = readFromArray(output)(ListOutputElem.listCodec)

    val unrecognizedChannel = elems.filter(_.channel != "conda-forge")
    if (unrecognizedChannel.nonEmpty) {
      System.err.println(
        s"Unrecognized channels in micromamba list output: ${unrecognizedChannel.map(_.channel).distinct.sorted.mkString(", ")}"
      )
      sys.exit(1)
    }

    val platform = options.mamba.condaPlatform
    val header =
      s"""# generated by  scala-cli mamba freeze
         |# platform: $platform
         |@EXPLICIT
         |""".stripMargin

    val linesTasks = elems.map { elem =>
      val url      = elem.url
      val artifact = Artifact(url)
      cache.file(artifact).run.map {
        case Left(e) => Left((artifact, e))
        case Right(f) =>
          val file = os.Path(f, os.pwd)
          val md5  = checksum("md5", file)
          Right(s"$url#$md5")
      }
    }
    val linesOrErrors = cache.logger.use {
      Task.gather.gather(linesTasks).unsafeRun()(cache.ec)
    }

    val errors = linesOrErrors.collect {
      case Left(e) => e
    }

    if (errors.nonEmpty)
      throw new FetchError.DownloadingArtifacts(errors)

    val lines = linesOrErrors.collect {
      case Right(l) => l
    }

    print(header)
    for (l <- lines)
      println(l)
  }

  private def computeDigest(sumType: String, localFile: os.Path): Array[Byte] = {
    val md = MessageDigest.getInstance(sumType)

    var is: InputStream = null
    try {
      is = os.read.inputStream(localFile)
      FileUtil.withContent(is, new FileUtil.UpdateDigest(md))
    }
    finally
      if (is != null) is.close()

    md.digest()
  }

  private def checksum(sumType: String, f: os.Path): String = {
    val rawMd5  = computeDigest(sumType, f)
    val baseMd5 = new BigInteger(1, rawMd5).toString(16)
    "0" * (baseMd5.length - 32) + baseMd5
  }

  private final case class ListOutputElem(
    name: String,
    platform: String,
    version: String,
    channel: String,
    dist_name: String
  ) {
    def url: String =
      s"https://anaconda.org/conda-forge/$name/$version/download/$platform/$dist_name.tar.bz2"
  }
  private object ListOutputElem {
    val listCodec: JsonValueCodec[List[ListOutputElem]] = JsonCodecMaker.make
  }
}
