"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6478],{8970:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>t,default:()=>f,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var i=n(4848),c=n(8453),a=n(2267);const l={title:"Format",sidebar_position:15},t=void 0,r={id:"commands/fmt",title:"Format",description:"Scala CLI supports formatting your code using Scalafmt:",source:"@site/docs/commands/fmt.md",sourceDirName:"commands",slug:"/commands/fmt",permalink:"/docs/commands/fmt",draft:!1,unlisted:!1,editUrl:"https://github.com/Virtuslab/scala-cli/edit/main/website/docs/commands/fmt.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{title:"Format",sidebar_position:15},sidebar:"tutorialSidebar",previous:{title:"IDE Setup",permalink:"/docs/commands/setup-ide"},next:{title:"Clean",permalink:"/docs/commands/clean"}},o={},d=[{value:"Scalafmt version and dialect",id:"scalafmt-version-and-dialect",level:3},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Scalafmt options",id:"scalafmt-options",level:3},{value:"Excluding sources",id:"excluding-sources",level:3},{value:"How <code>.scalafmt.conf</code> file is generated",id:"how-scalafmtconf-file-is-generated",level:3}];function h(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["Scala CLI supports formatting your code using ",(0,i.jsx)(s.a,{href:"https://scalameta.org/scalafmt/",children:"Scalafmt"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt .\n"})}),"\n",(0,i.jsx)(s.p,{children:"Under the hood, Scala CLI downloads and runs Scalafmt on your code."}),"\n",(0,i.jsxs)(s.p,{children:["If you\u2019re setting up a continuous integration (CI) server, Scala CLI also has you covered.\nYou can check formatting correctness using a ",(0,i.jsx)(s.code,{children:"--check"})," flag:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",metastring:"fail",children:"scala-cli fmt --check .\n"})}),"\n",(0,i.jsx)(s.h3,{id:"scalafmt-version-and-dialect",children:"Scalafmt version and dialect"}),"\n",(0,i.jsxs)(s.p,{children:["Scala CLI ",(0,i.jsx)(s.code,{children:"fmt"})," command supports passing the ",(0,i.jsx)(s.code,{children:"scalafmt"})," ",(0,i.jsx)(s.strong,{children:"version"})," and ",(0,i.jsx)(s.strong,{children:"dialect"})," directly from the command line, using the ",(0,i.jsx)(s.code,{children:"--scalafmt-dialect"})," and ",(0,i.jsx)(s.code,{children:"--scalafmt-version"})," options respectively:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"scala-cli fmt . --scalafmt-dialect scala3 --scalafmt-version 3.5.8\n"})}),"\n",(0,i.jsx)(s.p,{children:"You can skip passing either of those, which will make Scala CLI infer a default value:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If a ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file is present in the workspace and it has the field defined, the value will be read from there, unless explicitly specified with Scala CLI options."]}),"\n",(0,i.jsxs)(s.li,{children:["Otherwise, the default ",(0,i.jsx)(s.code,{children:"scalafmt"})," ",(0,i.jsx)(s.strong,{children:"version"})," will be the latest one used by your Scala CLI version (so it is subject to change when updating Scala CLI). The default ",(0,i.jsx)(s.strong,{children:"dialect"})," will be inferred based on the Scala version (defined explicitly by ",(0,i.jsx)(s.code,{children:"-S"})," option, or default version if the option is not passed)."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["It is possible to pass the configuration as a string directly from the command line, using ",(0,i.jsx)(s.code,{children:"--scalafmt-conf-str"})," option. If the configuration is passed this way, Scala CLI will behave exactly the same as if it found the specified configuration in the ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file in the workspace."]}),"\n",(0,i.jsx)(s.h4,{id:"example-1",children:"Example 1"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",metastring:"title=.scalafmt.conf",children:'version = "3.5.8"\nrunner.dialect = scala212\n'})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt --scalafmt-dialect scala213 .\n"})}),"\n",(0,i.jsxs)(s.p,{children:["For the setup above, ",(0,i.jsx)(s.code,{children:"fmt"})," will use:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:'version="3.5.8"'})," from the file"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dialect=scala213"}),", because passed ",(0,i.jsx)(s.code,{children:"--scalafmt-dialect"})," option overrides dialect found in the file"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example-2",children:"Example 2"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",metastring:"title=.scalafmt.conf",children:'version = "2.7.5"\n'})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt --scalafmt-version 3.5.8 .\n"})}),"\n",(0,i.jsxs)(s.p,{children:["For the setup above, ",(0,i.jsx)(s.code,{children:"fmt"})," will use:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:'version="3.5.8"'}),", because passed ",(0,i.jsx)(s.code,{children:"--scalafmt-version"})," option overrides version from the file"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dialect=scala3"}),", because dialect is neither passed as an option nor is it present in the configuration file, so it is inferred based on the Scala version; the Scala version wasn't explicitly specified in the command either, so it falls back to the default Scala version - the latest one, thus the resulting dialect is ",(0,i.jsx)(s.code,{children:"scala3"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"scalafmt-options",children:"Scalafmt options"}),"\n",(0,i.jsxs)(s.p,{children:["It is possible to pass native ",(0,i.jsx)(s.code,{children:"scalafmt"})," options with the ",(0,i.jsx)(s.code,{children:"-F"})," (short for ",(0,i.jsx)(s.code,{children:"--scalafmt-arg"}),"), for example:"]}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt -F --version\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"scalafmt 3.5.8\n"})})]}),"\n",(0,i.jsxs)(s.p,{children:["For the available options please refer to ",(0,i.jsx)(s.code,{children:"scalafmt"})," help, which can be viewed with the ",(0,i.jsx)(s.code,{children:"--scalafmt-help"})," option (which\nis just an alias for ",(0,i.jsx)(s.code,{children:"-F --help"}),"):"]}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt --scalafmt-help\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"scalafmt 3.5.8\nUsage: scalafmt [options] [<file>...]\n\n  -h, --help               prints this usage text\n  -v, --version            print version \n(...)\n"})})]}),"\n",(0,i.jsx)(s.h3,{id:"excluding-sources",children:"Excluding sources"}),"\n",(0,i.jsxs)(s.p,{children:["Because of the way Scala CLI invokes ",(0,i.jsx)(s.code,{children:"scalafmt"})," under the hood, sources are always being passed to it explicitly. This\nin turn means that regardless of how the sources were passed, ",(0,i.jsx)(s.code,{children:"scalafmt"})," exclusion paths (the ",(0,i.jsx)(s.code,{children:"project.excludePaths"}),")\nwould be ignored. In order to prevent that from happening, the ",(0,i.jsx)(s.code,{children:"--respect-project-filters"})," option is set to ",(0,i.jsx)(s.code,{children:"true"})," by\ndefault."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",metastring:"title=.scalafmt.conf",children:'version = "3.5.8"\nrunner.dialect = scala3\nproject {\n  includePaths = [\n    "glob:**.scala",\n    "regex:.*\\\\.sc"\n  ]\n  excludePaths = [\n    "glob:**/should/not/format/**.scala"\n  ]\n}\n'})}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt . --check\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"All files are formatted with scalafmt :)\n"})})]}),"\n",(0,i.jsxs)(s.p,{children:["You can explicitly set it to false if you want to disregard any filters configured in the ",(0,i.jsx)(s.code,{children:"project.excludePaths"})," setting\nin your ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," for any reason."]}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli fmt . --check --respect-project-filters=false\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"--- a/.../should/not/format/ShouldNotFormat.scala\n+++ b/.../should/not/format/ShouldNotFormat.scala\n@@ -1,3 +1,3 @@\n class ShouldNotFormat {\n-                       println()\n+  println()\n }\n"})})]}),"\n",(0,i.jsxs)(s.h3,{id:"how-scalafmtconf-file-is-generated",children:["How ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file is generated"]}),"\n",(0,i.jsxs)(s.p,{children:["The Scala CLI ",(0,i.jsx)(s.code,{children:"fmt"})," command runs ",(0,i.jsx)(s.code,{children:"scalafmt"})," under the hood, which ",(0,i.jsx)(s.em,{children:"normally"})," requires ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," configuration file with explicitly specified ",(0,i.jsx)(s.strong,{children:"version"})," and ",(0,i.jsx)(s.strong,{children:"dialect"})," fields. The way it is handled by Scala CLI is as follows:"]}),"\n",(0,i.jsxs)(s.p,{children:["At the beginning ",(0,i.jsx)(s.code,{children:"fmt"})," looks for the configuration inside the file specified in the ",(0,i.jsx)(s.code,{children:"--scalafmt-conf"})," option. If the option is not passed or the file doesn't exist, ",(0,i.jsx)(s.code,{children:"fmt"})," looks for the existing configuration file inside ",(0,i.jsx)(s.strong,{children:"current workspace"})," directory. If the file is still not found, ",(0,i.jsx)(s.code,{children:"fmt"})," looks for it inside ",(0,i.jsx)(s.strong,{children:"git root"})," directory. There are 3 possible cases:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Configuration file with the specified version and dialect is found."}),"\n",(0,i.jsx)(s.li,{children:"Configuration file is found, but it doesn't have specified version or dialect."}),"\n",(0,i.jsx)(s.li,{children:"Configuration file is not found."}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"first"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," uses the found ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"second"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," creates a ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file inside the ",(0,i.jsx)(s.code,{children:".scala-build"})," directory. Content of the previously found file is copied into the newly created file, missing parameters are ",(0,i.jsx)(s.a,{href:"#scalafmt-version-and-dialect",children:"inferred"})," and written into the same file. Created file is used to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"third"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," creates a ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file inside the ",(0,i.jsx)(s.code,{children:".scala-build"})," directory, writes ",(0,i.jsx)(s.a,{href:"#scalafmt-version-and-dialect",children:"inferred"})," version and dialect into it and uses it to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.code,{children:"--save-scalafmt-conf"})," option is passed, then ",(0,i.jsx)(s.code,{children:"fmt"})," command behaves as follows:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"first"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," uses the found ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"second"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," ",(0,i.jsx)(s.a,{href:"#scalafmt-version-and-dialect",children:"infers"})," missing parameters, writes them directly into the previously found file and then uses this file to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In the ",(0,i.jsx)(s.strong,{children:"third"})," case ",(0,i.jsx)(s.code,{children:"fmt"})," creates a ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file in the current workspace directory, writes ",(0,i.jsx)(s.a,{href:"#scalafmt-version-and-dialect",children:"inferred"})," version and dialect into it and uses it to run ",(0,i.jsx)(s.code,{children:"scalafmt"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["If the configuration is passed in the ",(0,i.jsx)(s.code,{children:"--scalafmt-conf-str"})," option, Scala CLI will behave exactly the same as if it found the specified configuration in a ",(0,i.jsx)(s.code,{children:".scalafmt.conf"})," file in the workspace."]})})]})}function f(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},2267:(e,s,n)=>{n.d(s,{Z:()=>l,b:()=>t});n(6540);var i=n(3554),c=n.n(i),a=n(4848);function l(e){let{children:s}=e;return(0,a.jsx)("div",{className:"runnable-command",children:s})}function t(e){let{url:s}=e;return(0,a.jsx)(c(),{playing:!0,loop:!0,muted:!0,controls:!0,width:"100%",height:"",url:s})}}}]);