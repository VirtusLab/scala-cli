"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9785],{2267:(e,n,a)=>{a.d(n,{Z:()=>c,b:()=>r});a(6540);var s=a(3554),i=a.n(s),l=a(4848);function c(e){let{children:n}=e;return(0,l.jsx)("div",{className:"runnable-command",children:n})}function r(e){let{url:n}=e;return(0,l.jsx)(i(),{playing:!0,loop:!0,muted:!0,controls:!0,width:"100%",height:"",url:n})}},9094:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"guides/introduction/old-runner-migration","title":"Migrating from the old Scala runner","description":"As of SIP-46, Scala CLI has been accepted as the new scala","source":"@site/docs/guides/introduction/old-runner-migration.md","sourceDirName":"guides/introduction","slug":"/guides/introduction/old-runner-migration","permalink":"/docs/guides/introduction/old-runner-migration","draft":false,"unlisted":false,"editUrl":"https://github.com/Virtuslab/scala-cli/edit/main/website/docs/guides/introduction/old-runner-migration.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"title":"Migrating from the old Scala runner","sidebar_position":15},"sidebar":"tutorialSidebar","previous":{"title":"Scala Toolkit","permalink":"/docs/guides/introduction/toolkit"},"next":{"title":"Scripts","permalink":"/docs/guides/scripting/scripts"}}');var i=a(4848),l=a(8453),c=a(2267);const r={title:"Migrating from the old Scala runner",sidebar_position:15},o="Migrating from the old scala runner",t={},d=[{value:"How to start using Scala CLI as the new <code>scala</code> command?",id:"how-to-start-using-scala-cli-as-the-new-scala-command",level:2},{value:"Can I still use the old <code>scala</code> runner with Scala 3.5+?",id:"can-i-still-use-the-old-scala-runner-with-scala-35",level:2},{value:"How has the passing of arguments been changed from the old <code>scala</code> runner to Scala CLI?",id:"how-has-the-passing-of-arguments-been-changed-from-the-old-scala-runner-to-scala-cli",level:2},{value:"The old ways",id:"the-old-ways",level:3},{value:"The ways of Scala CLI",id:"the-ways-of-scala-cli",level:3},{value:"The Scala CLI <code>shebang</code> sub-command",id:"the-scala-cli-shebang-sub-command",level:3},{value:"How are the old <code>scala</code> runner options supported?",id:"how-are-the-old-scala-runner-options-supported",level:2},{value:"Fully supported old <code>scala</code> runner options",id:"fully-supported-old-scala-runner-options",level:3},{value:"Old <code>scala</code> runner options which have a different meaning in Scala CLI",id:"old-scala-runner-options-which-have-a-different-meaning-in-scala-cli",level:3},{value:"Deprecated and unsupported old <code>scala</code> runner options",id:"deprecated-and-unsupported-old-scala-runner-options",level:3},{value:"Scala compiler options",id:"scala-compiler-options",level:3},{value:"How does Scala CLI detect if it&#39;s running a script or a main method?",id:"how-does-scala-cli-detect-if-its-running-a-script-or-a-main-method",level:2},{value:"Main class in a <code>.scala</code> input",id:"main-class-in-a-scala-input",level:3},{value:"Main class in a <code>.sc</code> input",id:"main-class-in-a-sc-input",level:3},{value:"Script syntax in an <code>.sc</code> file",id:"script-syntax-in-an-sc-file",level:3},{value:"Script syntax in a <code>.scala</code> file",id:"script-syntax-in-a-scala-file",level:3},{value:"Inputs with no extension",id:"inputs-with-no-extension",level:3},{value:"How to migrate scripts with the old <code>scala</code> runner in the shebang header to Scala CLI?",id:"how-to-migrate-scripts-with-the-old-scala-runner-in-the-shebang-header-to-scala-cli",level:2},{value:"Example shebang script with the Scala <code>2.13.x</code> old <code>scala</code> runner",id:"example-shebang-script-with-the-scala-213x-old-scala-runner",level:3},{value:"Example shebang script with the Scala <code>3.x</code> old <code>scala</code> runner",id:"example-shebang-script-with-the-scala-3x-old-scala-runner",level:3},{value:"Example shebang script with Scala CLI",id:"example-shebang-script-with-scala-cli",level:3},{value:"How to run a main class from compiled sources with Scala CLI?",id:"how-to-run-a-main-class-from-compiled-sources-with-scala-cli",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsxs)(n.h1,{id:"migrating-from-the-old-scala-runner",children:["Migrating from the old ",(0,i.jsx)(n.code,{children:"scala"})," runner"]})}),"\n",(0,i.jsxs)(n.p,{children:["As of ",(0,i.jsx)(n.a,{href:"https://github.com/scala/improvement-proposals/pull/46",children:"SIP-46"}),", Scala CLI has been accepted as the new ",(0,i.jsx)(n.code,{children:"scala"}),"\ncommand."]}),"\n",(0,i.jsxs)(n.p,{children:["In that context, the purpose of this guide is to highlight the key differences between the old ",(0,i.jsx)(n.code,{children:"scala"})," script\nand Scala CLI to make the migration as smooth as possible for users."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If you are looking for an overview of Scala CLI basics, refer to ",(0,i.jsx)(n.a,{href:"/docs/commands/basics",children:"the Basics page"}),".\nIf you merely want to get started with Scala CLI, you might want to first look\nat ",(0,i.jsx)(n.a,{href:"/docs/getting_started",children:"the Getting started page"}),"."]})}),"\n",(0,i.jsxs)(n.h2,{id:"how-to-start-using-scala-cli-as-the-new-scala-command",children:["How to start using Scala CLI as the new ",(0,i.jsx)(n.code,{children:"scala"})," command?"]}),"\n",(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"https://www.scala-lang.org/download/",children:"official instructions for installing Scala"}),".\nScala CLI is available as the ",(0,i.jsx)(n.code,{children:"scala"})," command alongside the Scala distribution in Scala 3.5.0 and later."]}),"\n",(0,i.jsxs)(n.h2,{id:"can-i-still-use-the-old-scala-runner-with-scala-35",children:["Can I still use the old ",(0,i.jsx)(n.code,{children:"scala"})," runner with Scala 3.5+?"]}),"\n",(0,i.jsxs)(n.p,{children:["Yes, even though its usage has been deprecated, it is still available under the ",(0,i.jsx)(n.code,{children:"scala_legacy"})," command.\nHowever, it is likely to be dropped in a future version."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala_legacy -version\n# [warning] MainGenericRunner class is deprecated since Scala 3.5.0, and Scala CLI features will not work.\n# [warning] Please be sure to update to the Scala CLI launcher to use the new features.\n# [warning] Check the Scala 3.5.0 release notes to troubleshoot your installation.\n# Scala code runner version 3.5.0 -- Copyright 2002-2024, LAMP/EPFL\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"how-has-the-passing-of-arguments-been-changed-from-the-old-scala-runner-to-scala-cli",children:["How has the passing of arguments been changed from the old ",(0,i.jsx)(n.code,{children:"scala"})," runner to Scala CLI?"]}),"\n",(0,i.jsx)(n.p,{children:"Let us take a closer look on how the old runner handled arguments when compared to Scala CLI."}),"\n",(0,i.jsx)(n.h3,{id:"the-old-ways",children:"The old ways"}),"\n",(0,i.jsx)(n.p,{children:"In the old runner, the first argument was treated as the input source, while the second and following arguments\nwere considered program arguments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=Source.scala",children:'@main def main(args: String*): Unit = println(args.mkString(" "))\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala_legacy Source.scala programArg1 programArg2\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since everything after the first argument had to be arbitrarily read as a program argument, regardless of format, all\nrunner options had to be passed before the source input."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala_legacy -save Source.scala programArg1 programArg2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"the-ways-of-scala-cli",children:"The ways of Scala CLI"}),"\n",(0,i.jsxs)(n.p,{children:["With Scala CLI's default way of handling arguments, inputs and program arguments have to be\ndivided by ",(0,i.jsx)(n.code,{children:"--"}),". There is no limit for the number of either."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=Source2.scala",children:'def placeholder = println("Example extra source")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"ignore",children:"scala Source.scala Source2.scala -- programArg1 programArg2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, a Scala CLI sub-command can be passed before the inputs section.\nFor example, to call the above example specifying the ",(0,i.jsx)(n.code,{children:"run"})," sub-command explicitly, pass it like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala run Source.scala Source2.scala -- programArg1 programArg2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["More on sub-commands can be found ",(0,i.jsx)(n.a,{href:"/docs/commands/basics",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Runner options can be passed on whatever position in the inputs section (before ",(0,i.jsx)(n.code,{children:"--"}),").\nFor example, all the following examples are correct ways to specify the Scala version explicitly as ",(0,i.jsx)(n.code,{children:"3.2"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala -S 3.2 Source.scala Source2.scala -- programArg1 programArg2\nscala Source.scala -S 3.2 Source2.scala -- programArg1 programArg2\nscala Source.scala Source2.scala -S 3.2 -- programArg1 programArg2\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The exception to this rule are the launcher options, like ",(0,i.jsx)(n.code,{children:"--cli-version"})," or ",(0,i.jsx)(n.code,{children:"--cli-scala-version"}),".\nThose have to be passed before the inputs section (before any source inputs)."]}),(0,i.jsxs)(n.p,{children:["For example, to explicitly specify the launcher should run Scala CLI ",(0,i.jsx)(n.code,{children:"v1.5.0"}),", pass it like this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala --cli-version 1.5.0 Source.scala Source2.scala -- programArg1 programArg2\n"})}),(0,i.jsx)(n.p,{children:"Also, if a Scala CLI sub-command is being passed explicitly, all launcher options have to be passed before the\nsub-command."}),(0,i.jsxs)(n.p,{children:["For example, to call ",(0,i.jsxs)(n.a,{href:"/docs/commands/package",children:["the ",(0,i.jsx)(n.code,{children:"package"})," sub-command"]})," using the nightly CLI version, do it like this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"ignore",children:"scala --cli-version nightly package --help\n"})})]}),"\n",(0,i.jsxs)(n.h3,{id:"the-scala-cli-shebang-sub-command",children:["The Scala CLI ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command"]}),"\n",(0,i.jsxs)(n.p,{children:["To provide better support for shebang scripts, Scala CLI\nhas ",(0,i.jsxs)(n.a,{href:"/docs/commands/shebang",children:["a dedicated ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command"]}),", which handles arguments similarly to the old ",(0,i.jsx)(n.code,{children:"scala"}),"\nscript."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala shebang Source.scala programArg1 programArg2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The purpose of the ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command is essentially to only be used in a shebang header (more\ndetails on that can be found ",(0,i.jsx)(n.a,{href:"#example-shebang-script-with-scala-cli",children:"in a later section of this guide"})," or in the\nseparate ",(0,i.jsx)(n.a,{href:"/docs/guides/scripting/shebang",children:"shebang scripts' guide"}),"), but nothing is really stopping you from using it from the command\nline, if you're used to how the old ",(0,i.jsx)(n.code,{children:"scala"})," runner handled arguments. Just bear in mind that it is not the intended user\nexperience."]}),"\n",(0,i.jsxs)(n.h2,{id:"how-are-the-old-scala-runner-options-supported",children:["How are the old ",(0,i.jsx)(n.code,{children:"scala"})," runner options supported?"]}),"\n",(0,i.jsxs)(n.p,{children:["For backwards compatibility's sake, Scala CLI accepts all the old ",(0,i.jsx)(n.code,{children:"scala"})," runner options, although many of them have\nbeen deprecated and are no longer supported in the new runner. This includes accepting all the Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," and ",(0,i.jsx)(n.code,{children:"3.x"}),"\nrespective runners' specific options."]}),"\n",(0,i.jsxs)(n.h3,{id:"fully-supported-old-scala-runner-options",children:["Fully supported old ",(0,i.jsx)(n.code,{children:"scala"})," runner options"]}),"\n",(0,i.jsxs)(n.p,{children:["The following old ",(0,i.jsx)(n.code,{children:"scala"})," runner options are fully supported by Scala CLI, meaning that they deliver similar or expanded\nfunctionalities with backwards-compatible syntax:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-e"}),", which is an alias for Scala CLI's ",(0,i.jsx)(n.code,{children:"--execute-script"})," and a close synonym\nfor ",(0,i.jsx)(n.a,{href:"/docs/guides/advanced/snippets#examples",children:(0,i.jsx)(n.code,{children:"--script-snippet"})})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-v"})," / ",(0,i.jsx)(n.code,{children:"-verbose"})," / ",(0,i.jsx)(n.code,{children:"--verbose"}),", which can be passed multiple times with Scala CLI, increasing the verbosity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-cp"})," / ",(0,i.jsx)(n.code,{children:"-classpath"})," / ",(0,i.jsx)(n.code,{children:"--class-path"}),", which adds compiled classes and jars to the class path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-version"})," / ",(0,i.jsx)(n.code,{children:"--version"}),", which prints the currently run Scala CLI ",(0,i.jsx)(n.a,{href:"/docs/commands/version",children:"version information"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-with-compiler"}),", which adds the Scala compiler dependency to the Scala CLI project"]}),"\n",(0,i.jsxs)(n.li,{children:["Scala compiler options (with some requiring to be passed with ",(0,i.jsx)(n.code,{children:"-O"}),", more info\nin ",(0,i.jsx)(n.a,{href:"#scala-compiler-options",children:"the section below"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-J<arg>"})," Java options"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-Dname=prop"})," Java properties"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"old-scala-runner-options-which-have-a-different-meaning-in-scala-cli",children:["Old ",(0,i.jsx)(n.code,{children:"scala"})," runner options which have a different meaning in Scala CLI"]}),"\n",(0,i.jsxs)(n.p,{children:["The following old ",(0,i.jsx)(n.code,{children:"scala"})," runner options not only are not supported with their old functionalities, but have a different\nmeaning in Scala CLI:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-i"}),", which is now an alias for Scala CLI's ",(0,i.jsxs)(n.a,{href:"/docs/reference/cli-options#--interactive",children:[(0,i.jsx)(n.code,{children:"--interactive"})," mode"]})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-h"})," / ",(0,i.jsx)(n.code,{children:"-help"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["in the old Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," ",(0,i.jsx)(n.code,{children:"scala"})," runner, it used to print the help of the runner"]}),"\n",(0,i.jsxs)(n.li,{children:["in the old Scala ",(0,i.jsx)(n.code,{children:"3.x"})," ",(0,i.jsx)(n.code,{children:"scala"})," runner however, it used to print the Scala compiler help instead"]}),"\n",(0,i.jsxs)(n.li,{children:["Scala CLI takes an approach similar to the old Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," runner, and it prints Scala CLI help"]}),"\n",(0,i.jsxs)(n.li,{children:["to view the Scala compiler help with Scala CLI, pass\nthe ",(0,i.jsx)(n.a,{href:"/docs/commands/compile#scala-compiler-help",children:"--scalac-help"})," option instead"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"deprecated-and-unsupported-old-scala-runner-options",children:["Deprecated and unsupported old ",(0,i.jsx)(n.code,{children:"scala"})," runner options"]}),"\n",(0,i.jsxs)(n.p,{children:["The following old ",(0,i.jsx)(n.code,{children:"scala"})," runner options have been deprecated and even though they are accepted by Scala CLI (passing\nthem will not cause an error), they are ignored with an appropriate warning:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-save"}),", refer to ",(0,i.jsxs)(n.a,{href:"/docs/commands/package#library-jars",children:["the ",(0,i.jsx)(n.code,{children:"package"})," sub-command"]})," on how to package a Scala CLI\nproject to a JAR"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-nosave"}),", a JAR file is now never saved unless ",(0,i.jsxs)(n.a,{href:"/docs/commands/package",children:["the ",(0,i.jsx)(n.code,{children:"package"})," sub-command"]})," is called"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-howtorun"})," / ",(0,i.jsx)(n.code,{children:"--how-to-run"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Scala CLI assumes how a file is to be run based on its file extension (and optionally its shebang header). This\ncannot be overridden with a command line option, so ensure your inputs use the correct file extension or have\nthe ",(0,i.jsx)(n.a,{href:"#example-shebang-script-with-scala-cli",children:"shebang header"})," defined. This is sort of the equivalent of the\nold ",(0,i.jsx)(n.code,{children:"-howtorun guess"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["To run the ",(0,i.jsx)(n.code,{children:"REPL"}),", refer to ",(0,i.jsxs)(n.a,{href:"/docs/commands/repl",children:["the ",(0,i.jsx)(n.code,{children:"repl"})," sub-command"]})]}),"\n",(0,i.jsxs)(n.li,{children:["This option has been largely replaced with Scala CLI's ",(0,i.jsx)(n.a,{href:"/docs/commands/basics",children:"sub-commands"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-I"}),", to preload the extra files for the ",(0,i.jsx)(n.code,{children:"REPL"}),", try passing them as inputs\nfor ",(0,i.jsx)(n.a,{href:"/docs/commands/repl",children:"the repl sub-command"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-nc"})," / ",(0,i.jsx)(n.code,{children:"nocompdaemon"}),", the underlying script runner class can no longer be picked explicitly, as with the old ",(0,i.jsx)(n.code,{children:"scala"}),"\nrunner"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-run"})," - Scala CLI does not support explicitly forcing the old run mode. Just pass your sources as inputs and ensure\nthey are in the correct format and extension."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scala-compiler-options",children:"Scala compiler options"}),"\n",(0,i.jsxs)(n.p,{children:["All compiler options are supported when passed with the ",(0,i.jsx)(n.code,{children:"--scalac-option"})," flag (or the ",(0,i.jsx)(n.code,{children:"-O"})," alias for short).\nHowever, many compiler options can also be passed directly.\nFor more information, refer\nto ",(0,i.jsxs)(n.a,{href:"/docs/commands/compile#scala-compiler-options",children:["the Scala compiler options section of the ",(0,i.jsx)(n.code,{children:"compile"})," sub-command doc"]}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"how-does-scala-cli-detect-if-its-running-a-script-or-a-main-method",children:"How does Scala CLI detect if it's running a script or a main method?"}),"\n",(0,i.jsxs)(n.p,{children:["To answer this question, some disambiguation is necessary.\nThe most important thing to note is that this has been handled differently by the 2 old ",(0,i.jsx)(n.code,{children:"scala"})," runners (for\nScala ",(0,i.jsx)(n.code,{children:"2.13.x"})," and for ",(0,i.jsx)(n.code,{children:"3.x"}),"), so a\nconsistent behaviour hasn't really been established before Scala CLI."]}),"\n",(0,i.jsxs)(n.p,{children:["The Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," old ",(0,i.jsx)(n.code,{children:"scala"})," runner was the most flexible, automatically detecting if what is being run is a script or\nan\nobject based on the source contents. This automatic detection was also possible to be overridden with the ",(0,i.jsx)(n.code,{children:"-howtorun"}),"\nrunner option (which has been\ndeprecated and is not supported in Scala CLI,\nas ",(0,i.jsx)(n.a,{href:"#deprecated-and-unsupported-old-scala-runner-options",children:"noted in an earlier section"}),").\nThis also means that the ",(0,i.jsx)(n.code,{children:"2.13.x"})," old ",(0,i.jsx)(n.code,{children:"scala"})," runner did not really care about file extensions much."]}),"\n",(0,i.jsxs)(n.p,{children:["In contrast, the Scala ",(0,i.jsx)(n.code,{children:"3.x"})," old ",(0,i.jsx)(n.code,{children:"scala"})," runner always expects to find a main method, potentially but not necessarily\nusing ",(0,i.jsxs)(n.a,{href:"https://docs.scala-lang.org/scala3/book/methods-main-methods.html",children:["the Scala 3 idiomatic ",(0,i.jsx)(n.code,{children:"@main"})," annotation"]}),".\nThis means that the Scala ",(0,i.jsx)(n.code,{children:"3.x"})," runner respected main methods defined in ",(0,i.jsx)(n.code,{children:".sc"})," files, but did not support script\nsyntax (top level definitions with no explicit main method)."]}),"\n",(0,i.jsxs)(n.p,{children:["Scala CLI's approach is perhaps the most restrictive here.\nIt accepts explicitly defined main methods in ",(0,i.jsx)(n.code,{children:".scala"})," sources and script syntax in ",(0,i.jsx)(n.code,{children:".sc"})," sources, without any\nadditional flexibility."]}),"\n",(0,i.jsxs)(n.p,{children:["The only exception would be files with no file extension, but with a shebang header, ran with the ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command.\nThose are always treated as scripts (more details about this can be\nfound [in ",(0,i.jsx)(n.a,{href:"/docs/guides/scripting/shebang",children:"the shebang scripts' guide"}),"])."]}),"\n",(0,i.jsx)(n.p,{children:"Now, to give some examples."}),"\n",(0,i.jsxs)(n.h3,{id:"main-class-in-a-scala-input",children:["Main class in a ",(0,i.jsx)(n.code,{children:".scala"})," input"]}),"\n",(0,i.jsxs)(n.p,{children:["Of course, the simplest case is putting a main class into a ",(0,i.jsx)(n.code,{children:".scala"})," source, which is supported by both of the old\nrunners and by Scala CLI."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=Main.scala",children:'object Main {\n  def main(args: Array[String]): Unit = println(args.mkString(" "))\n}\n'})}),"\n",(0,i.jsxs)(c.Z,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala_legacy Main.scala Hello world\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala Main.scala -- Hello world\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Hello world\n"})})]}),"\n",(0,i.jsxs)(n.h3,{id:"main-class-in-a-sc-input",children:["Main class in a ",(0,i.jsx)(n.code,{children:".sc"})," input"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=main-in-script.sc",children:'object Main {\n  def main(args: Array[String]): Unit = println(args.mkString(" "))\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This case has been supported by both of the old ",(0,i.jsx)(n.code,{children:"scala"})," runners, but is not supported by Scala CLI, which expects a\nscript in a ",(0,i.jsx)(n.code,{children:".sc"})," input and wraps its contents in a main class of its own, not inspecting further for a nested one.\nIn other words, when explicitly declaring a main class when working with Scala CLI, you have to do it in a ",(0,i.jsx)(n.code,{children:".scala"}),"\nfile."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala main-in-script.sc -- Hello world \n# no output will be printed\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Running such an ",(0,i.jsx)(n.code,{children:".sc"})," file will not fail by the way, but neither will it print any output, since the appropriate method\nhasn't been called explicitly in the script."]}),"\n",(0,i.jsxs)(n.h3,{id:"script-syntax-in-an-sc-file",children:["Script syntax in an ",(0,i.jsx)(n.code,{children:".sc"})," file"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=script.sc",children:'println(args.mkString(" "))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This syntax is supported by the old Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," runner, but ",(0,i.jsx)(n.strong,{children:"not"})," by the old Scala ",(0,i.jsx)(n.code,{children:"3.x"})," one.\nThe Scala ",(0,i.jsx)(n.code,{children:"3.x"})," runner does not allow for top level definitions without an explicit main class."]}),"\n",(0,i.jsx)(n.p,{children:"However, it is supported by Scala CLI."}),"\n",(0,i.jsxs)(c.Z,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala script.sc -- Hello world\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Hello world\n"})})]}),"\n",(0,i.jsxs)(n.h3,{id:"script-syntax-in-a-scala-file",children:["Script syntax in a ",(0,i.jsx)(n.code,{children:".scala"})," file"]}),"\n",(0,i.jsxs)(n.p,{children:["Now for the inverted case, where script-style top level definitions are put in a ",(0,i.jsx)(n.code,{children:".scala"})," input."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=script.scala",children:'println(args.mkString(" "))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This has actually been supported by the old Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," runner.\nHowever, both the old Scala ",(0,i.jsx)(n.code,{children:"3.x"})," runner as well as Scala CLI do not support it."]}),"\n",(0,i.jsxs)(c.Z,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"fail",children:"scala script.scala -- Hello world\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'[error] ./ScriptInScala.scala:1:1\n[error] Illegal start of toplevel definition\n[error] println(args.mkString(" "))\n[error] ^^^^^^^\nError compiling project (Scala 3.2.2, JVM)\nCompilation failed\n'})})]}),"\n",(0,i.jsx)(n.h3,{id:"inputs-with-no-extension",children:"Inputs with no extension"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=no-extension-script",children:'println(args.mkString(" "))\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=no-extension-main-class",children:'object Main {\n  def main(args: Array[String]): Unit = println(args.mkString(" "))\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Files with no extensions have been supported in the ",(0,i.jsx)(n.code,{children:"2.13.x"})," old runner, but not in ",(0,i.jsx)(n.code,{children:"3.x"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Script syntax in files with no extension (or with extensions not indicating other kinds of sources, like ",(0,i.jsx)(n.code,{children:".java"}),") are\nsupported in Scala CLI via the ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command (and not otherwise).\nHowever, a shebang header is necessary. An example is given\nin ",(0,i.jsx)(n.a,{href:"#example-shebang-script-with-scala-cli",children:"a later section of this guide"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"how-to-migrate-scripts-with-the-old-scala-runner-in-the-shebang-header-to-scala-cli",children:["How to migrate scripts with the old ",(0,i.jsx)(n.code,{children:"scala"})," runner in the shebang header to Scala CLI?"]}),"\n",(0,i.jsxs)(n.p,{children:["As described\nin ",(0,i.jsx)(n.a,{href:"#how-has-the-passing-of-arguments-been-changed-from-the-old-scala-runner-to-scala-cli",children:"an earlier section of this guide"}),",\nthe way the old ",(0,i.jsx)(n.code,{children:"scala"})," runner handles arguments differs from Scala CLI."]}),"\n",(0,i.jsxs)(n.p,{children:["The old ",(0,i.jsx)(n.code,{children:"scala"})," script accepted arguments with syntax making it easy to use it in a shebang header.\nThat is, all arguments starting with the second were treated as program args, rather than input sources.\nThis is in contrast with the Scala CLI default way of handling arguments, where inputs and program arguments have to be\ndivided by ",(0,i.jsx)(n.code,{children:"--"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala Source.scala Source2.scala -- programArg1 programArg2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To better support shebang scripts, Scala CLI has a dedicated ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command, which handles arguments similarly to\nthe old ",(0,i.jsx)(n.code,{children:"scala"})," script."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala shebang Source.scala programArg1 programArg2\n"})}),"\n",(0,i.jsx)(n.p,{children:"For more concrete examples on how to change the shebang header in your existing scripts, look below."}),"\n",(0,i.jsxs)(n.h3,{id:"example-shebang-script-with-the-scala-213x-old-scala-runner",children:["Example shebang script with the Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})," old ",(0,i.jsx)(n.code,{children:"scala"})," runner"]}),"\n",(0,i.jsxs)(n.p,{children:["This is how an example shebang script could have looked like for the old ",(0,i.jsx)(n.code,{children:"scala"})," runner with Scala ",(0,i.jsx)(n.code,{children:"2.13.x"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"compile title=old-scala-shebang-213.sc",children:'#!/usr/bin/env scala\nprintln("Args: " + args.mkString(" "))\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"example-shebang-script-with-the-scala-3x-old-scala-runner",children:["Example shebang script with the Scala ",(0,i.jsx)(n.code,{children:"3.x"})," old ",(0,i.jsx)(n.code,{children:"scala"})," runner"]}),"\n",(0,i.jsxs)(n.p,{children:["This in turn is the Scala ",(0,i.jsx)(n.code,{children:"3.x"})," equivalent for its own old ",(0,i.jsx)(n.code,{children:"scala"})," runner."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=old-scala-shebang-3.sc",children:'#!/usr/bin/env scala\n@main def main(args: String*): Unit = println("Args: " + args.mkString(" "))\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-shebang-script-with-scala-cli",children:"Example shebang script with Scala CLI"}),"\n",(0,i.jsx)(n.p,{children:"This is an example of how a Scala CLI script with a shebang header looks like."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"compile title=scala-cli-shebang.sc",children:'#!/usr/bin/env -S scala-cli shebang\n  println("Args: " + args.mkString(" "))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The example above refers ",(0,i.jsx)(n.code,{children:"scala-cli"}),", as per the current default Scala CLI distribution.\nIf you have Scala CLI installed as ",(0,i.jsx)(n.code,{children:"scala"}),", then that should be changed to the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"compile title=scala-cli-as-scala-shebang.sc",children:'#!/usr/bin/env -S scala shebang\nprintln("Args: " + args.mkString(" "))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For more information about the ",(0,i.jsx)(n.code,{children:"shebang"})," sub-command, refer to ",(0,i.jsx)(n.a,{href:"/docs/commands/shebang",children:"the appropriate doc"}),".\nFor more details on how to use Scala CLI in shebang scripts, refer to ",(0,i.jsx)(n.a,{href:"/docs/guides/scripting/shebang",children:"the relevant guide"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"how-to-run-a-main-class-from-compiled-sources-with-scala-cli",children:"How to run a main class from compiled sources with Scala CLI?"}),"\n",(0,i.jsxs)(n.p,{children:["With the old ",(0,i.jsx)(n.code,{children:"scala"})," runner, running a main class from compiled sources was as simple as passing the main class name\nas an argument. The old runner would then assume that the current working directory is to be added to the classpath and could\nimplicitly run any compiled class files it would find."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"title=hello.scala",children:'@main def hello = println("Hello")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This syntax has been dropped and is no longer supported with the new ",(0,i.jsx)(n.code,{children:"scala"})," runner."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scalac hello.scala\nscala_legacy hello # NOTE: this syntax is not supported by Scala CLI\n# Hello\n"})}),"\n",(0,i.jsx)(n.p,{children:"With Scala CLI, all inputs have to be passed explicitly, so any compiled classes in the current working directory\nwould be ignored unless passed explicitly."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"clean",children:"scalac hello.scala\nscala run -cp .\n# Hello\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["If only the classpath is passed with ",(0,i.jsx)(n.code,{children:"-cp"}),", then the ",(0,i.jsx)(n.code,{children:"run"})," sub-command can't be skipped, as otherwise Scala CLI\nwill default to the REPL (as there are no explicit source file inputs present)."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"ignore",children:"scalac hello.scala\nscala -cp .\n# Welcome to Scala 3.5.0 (17, Java OpenJDK 64-Bit Server VM).\n# Type in expressions for evaluation. Or try :help.\n#                                                                                                                  \n# scala> \n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["It is possible to explicitly specify the main class to be run (for example, if there are multiple main classes\nin the build). The ",(0,i.jsx)(n.code,{children:"run"})," sub-command becomes optional then, as passing ",(0,i.jsx)(n.code,{children:"-M"})," indicates the intention to run something."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"clean",children:"scalac hello.scala\nscala -cp . -M hello\n# Hello\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["If you want to compile your sources with a separate command, and then run them later, you can also do it\nwith the ",(0,i.jsx)(n.code,{children:"compile"})," sub-command, rather than the ",(0,i.jsx)(n.code,{children:"scalac"})," script."]}),(0,i.jsx)(n.p,{children:"You don't have to specify the class files location, Scala CLI won't recompile them if they are up to date."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",metastring:"clean",children:"scala compile hello.scala\nscala hello.scala\n# Hello\n"})}),(0,i.jsxs)(n.p,{children:["Alternatively, you can also specify the location for the compiled classes explicitly, and then add them\nto the classpath, as you would with ",(0,i.jsx)(n.code,{children:"scalac"}),"."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"scala compile hello.scala -d compiled_classes\nscala run -cp compiled_classes\n# Hello\n"})})]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);