---
title: Package
sidebar_position: 8
---

The `package` command can package your Scala code in various formats, such as:
- [lightweight launcher JARs](#default-package-format)
- [standard library JARs](#library-jars)
- so called ["assemblies" or "fat JARs"](#assemblies)
- [docker container](#docker-container)
- [JavaScript files](#scalajs) for Scala.JS code
- [native executables](#scala-native) for Scala Native code
- [OS-specific formats](#os-specific-packages), such as deb or rpm (Linux), pkg (macOS), or MSI (Windows)

## Default package format

The default package format writes a *lightweight launcher JAR*, like the "bootstrap" JAR files [generated by coursier](https://get-coursier.io/docs/cli-bootstrap#bootstraps).
These JARs tend to have a small size (mostly containing only the byte code from your own sources),
can be generated fast,
and download their dependencies upon first launch, via [coursier](https://get-coursier.io).

These can be copied onto other machines, and will run fine there.
Their only requirement is that the `java` command needs to be available in the `PATH`:

```scala title=Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
```

```bash
scala-cli package Hello.scala -o hello
./hello
# Hello
```

<!-- Expected 
Hello
-->

## Library JARs

*Library JARs* are suitable if you plan to put the resulting JAR in a class path, rather than running it as is.
These follow the same format as the JARs of libraries published to Maven Central:

```scala title=MyLibrary.scala
package mylib

class MyLibrary {
  def message = "Hello"
}
```


```bash
scala-cli package MyLibrary.scala -o my-library.jar --library
javap -cp my-library.jar mylib.MyLibrary
# Compiled from "MyLibrary.scala"
# public class mylib.MyLibrary {
#   public java.lang.String message();
#   public mylib.MyLibrary();
# }
```

<!-- Expected:
MyLibrary.scala
public class mylib.MyLibrary
public java.lang.String message();
public mylib.MyLibrary();
-->

## Assemblies

*Assemblies* blend your dependencies and your sources' byte code together in a single JAR file.
As a result, assemblies can be run as is, just like [bootstraps](#default-package-format), but don't need to download
anything upon first launch.
Because of that, assemblies also tend to be bigger, and somewhat slower to generate:

<!-- clear -->

```scala title=Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
```

```bash
scala-cli package Hello.scala -o hello --assembly
./hello
# Hello
```

<!-- Expected:
Hello
-->

## Docker container

Scala CLI can create an executable application and package it into a docker image.

 For example, hereâ€™s an application that will be executed in a docker container:

```scala title=HelloDocker.scala
object HelloDocker extends App {
    println("Hello from Docker")
}
```

Passing `--docker` to the `package` sub-command generates a docker image.
The docker image name parameter `--docker-image-repository` is mandatory.

The following command generates a `hello-docker` image with the `latest` tag:

```bash
scala-cli package --docker HelloDocker.scala --docker-image-repository hello-docker
```

<!-- Expected:
Started building docker image with your application, it would take some time
Built docker image, run it with
  docker run hello-docker:latest
-->

```bash
docker run hello-docker
# Hello from Docker
```

<!-- Expected:
Hello from Docker
-->

You can also create Docker images for the Scala JS and Scala Native environments.
This command shows how to create a Docker image (`--docker`) for a Scala JS (`--js`) application:

```bash
scala-cli package --js --docker HelloDocker.scala --docker-image-repository hello-docker
```
<!-- Expected:
Started building docker image with your application, it would take some time
Built docker image, run it with
  docker run hello-docker:latest
-->

Packaging Scala Native applications to a Docker image is only supported on Linux.

 This command shows how to do that:

```bash ignore
scala-cli package --native --docker HelloDocker.scala --docker-image-repository hello-docker
```

## Scala.JS

Packaging Scala.JS applications results in a `.js` file, that can be run with `node`:

<!-- TODO: add something js specific -->

```scala title=HelloJs.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
```

```bash
scala-cli package --js HelloJs.scala -o hello.js
node hello.js
# Hello
```

<!-- Expected:
Hello
-->


Note that the Scala CLI doesn't offer to link the resulting JavaScript with linkers, such as Webpack (yet).

## Scala Native

Packaging a Scala Native application results in a native executable:

<!-- clear -->

<!-- TODO: add something native specific -->

```scala title=HelloNative.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
```

```bash
scala-cli package --native HelloNative.scala -S 2.13.6 -o hello
file hello
# hello: Mach-O 64-bit executable x86_64
./hello
# Hello
```

<!-- Expected:
Hello
-->

## OS-specific packages

Scala CLI also lets you package Scala code as OS-specific packages.
This feature is somewhat experimental, and supports the following formats, provided they're compatible with the operating system you're running `scala-cli` on:

- [DEB](#debian) (Linux)
- [RPM](#redhat) (Linux)
- [PKG](#macos-pkg) (macOS)
- [MSI](#windows) (Windows)

```scala Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
```

```bash ignore
scala-cli package --deb Hello.scala -o hello.deb
file hello
# hello: Mach-O 64-bit executable x86_64
./hello
# Hello
```

### Debian

DEB is the package format for the Debian Linux distribution.
To build a Debian package, you will need to have [`dpkg-deb`](http://manpages.ubuntu.com/manpages/trusty/pl/man1/dpkg-deb.1.html) installed.

Example:

```bash ignore
scala-cli package --deb --output 'path.deb' Hello.scala
```

#### Mandatory arguments
* version
* maintainer
* description
* output-path

#### Optional arguments
* force
* launcher-app
* debian-conflicts
* debian-dependencies
* architecture

### RedHat

RPM is the software package format for RedHat distributions.
To build a RedHat Package, you will need to have [`rpmbuild`](https://linux.die.net/man/8/rpmbuild) installed.

Example:

```bash ignore
scala-cli package --rpm --output 'path.rpm' Hello.scala
```

#### Mandatory arguments
* version
* description
* license
* output-path

#### Optional arguments
* force
* launcher-app
* release
* rpm-architecture

### macOS (PKG)

PKG is the software package format for macOs.
To build a PKG you will need to have [`pkgbuild`](https://www.unix.com/man-page/osx/1/pkgbuild/) installed. 

Example:

```bash ignore
`scala-cli package --pkg --output 'path.pkg` Hello.scala
```

#### Mandatory arguments
* version
* identifier
* output-path

#### Optional arguments
* force
* launcher-app

### Windows

MSI is the software package format for Windows distributions.
To build a Windows installer, you will need to have [`WIX Toolset`](https://wixtoolset.org/) installed.

Example:

```cmd
scala-cli package --msi --output 'path.msi` Hello.scala
```

#### Mandatory arguments
* version
* maintainer
* licence-path
* product-name
* output-path

#### Optional arguments
* force
* launcher-app
* exit-dialog
* logo-path
