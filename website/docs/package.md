---
title: Package
sidebar_position: 8
---

The `package` command packages your Scala code in various formats, such as
- ["bootstrap" JARs](#default-package-format)
- [standard library JARs](#library-jars)
- so called ["assemblies" or "fat JARs"](#assemblies)
- [JavaScript files](#scalajs) for Scala.JS code
- [native executables](#scala-native) for Scala Native code
- [OS-specific formats](#os-specific-packages), such as deb or rpm (Linux), pkg (macOS), or MSI (Windows)

## Default package format

The default package format writes a "bootstrap" JAR, like the ones
[generated by coursier](https://get-coursier.io/docs/cli-bootstrap#bootstraps). These
JARs tend to have a small size (they mostly only contain the byte code of your own sources),
can be generated fast,
and download their dependencies upon first launch, via [coursier](https://get-coursier.io).

These can be copied on other machines, and run fine there. Their only requirement is
that the `java` command needs to be available in the `PATH`.

```text
$ cat Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
$ scala-cli package Hello.scala -o hello
$ ./hello
Hello
```

## Library JARs

Library JARs are suitable if you plan to put the resulting JAR in a class path, rather than running it as is.
These follow the same format as the JARs of libraries published to Maven Central for example.

```text
$ cat MyLibrary.scala
package mylib
class MyLibrary {
  def message = "Hello"
}
$ scala-cli package MyLibrary.scala -o my-library.jar --library
$ javap -cp my-library.jar mylib.MyLibrary
Compiled from "MyLibrary.scala"
public class mylib.MyLibrary {
  public java.lang.String message();
  public mylib.MyLibrary();
}
```

## Assemblies

Assemblies blend your dependencies and your sources' byte code together in a single JAR. As a result,
assemblies can be run as is, just like [bootstraps](#default-package-format), but don't need to download
anything upon first launch. Because of that, assemblies also tend to be bigger, and somewhat slower to generate.

```text
$ cat Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
$ scala-cli package Hello.scala -o hello --assembly
$ ./hello
Hello
```

## Scala.JS

Packaging Scala.JS applications results in a `.js` file, that can be run with `node` for example:
```text
$ cat Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
$ scala-cli package --js Hello.scala -o hello.js
$ node hello.js
Hello
```

Note that the Scala CLI doesn't offer to link the resulting JavaScript with linkers, such as Webpack, yet.

## Scala Native

Package Scala Native applications results in a native executable:
```text
$ cat Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
$ scala-cli package --native Hello.scala -o hello
$ file hello
hello: Mach-O 64-bit executable x86_64
$ ./hello
Hello
```

## OS-specific packages

The Scala CLI also offers to package Scala code as OS-specific packages. This feature is somewhat experimental,
and supports the following formats, provided they're compatible with the operating system you're running `scala-cli` on:
- DEB (Linux)
- RPM (Linux)
- PKG (macOS)
- MSI (Windows)

```text
$ cat Hello.scala
object Hello {
  def main(args: Array[String]): Unit =
    println("Hello")
}
$ scala-cli package --deb Hello.scala -o hello.deb
$ file hello
hello: Mach-O 64-bit executable x86_64
$ ./hello
Hello
```
